Book Name: Learning Perl
Author: Randal L. Schwartz, Brain D Foy, Tom Phoenix
Edition: 6th Ed
Publisher: O'Reilly
Year: 2011
ISBN: 9781449303587

Chapter 16: Process Management
A) The system Function
   The simplest way to launch a child process in Perl to run a program is the
   system command creates an identical copy of your Perl program, called the
   child process. The child process immediately changes ifself into the
   command that you want to run, such as date, inherting Perl's standard
   input, standard output, and standard error. This means that the normal
   short date-and-time string generated by date ends up wherever Perl's STDOUT
   was already going.
   e.g. see ch16eg1.pl
   a) Avoiding the Shell
   	  The system operator may also be invoked with more than one argument, in
	  which case a shell doesn't get involved, no matter how complicated the
	  text.
	  e.g. my $tarfile = 'something*wicked.tar';
	  	   my @dirs = qw(fred|flintstone <barney&rubble> betty);
		   system 'tar', 'cvf', $tarfile, @dirs;
	  The tar command will have five parameters. Compare that with this
	  security problem:
	       system "tar cvf $tarfile @dirs";
	  Here, we've now piped a bunch of stuff into a flintstone command and put
	  it into the background, and opened betty for output. That's a relatively
	  tame effect, but what if @dirs was something more interesting, such as:
	  	   my @dirs = qw(; rm -rf /);
	  It doesn't matter that @dirs is a list because Perl simply interpolates
	  it into the single string to pass to system. And that's a bit scary,
	  especially if those variables are from user input - such as from a web
	  form or something. So if you can arrange things so that you can use the
	  multiple argument version of system, you probably should use that way to
	  launch your subprocess. You'll have to give up the ability to have the
	  shell do the work for you to set up I/O redirection, background
	  processes, and the like, though.
	  Note that redundantly, a single argument invocation of system is nearly
	  equivalent to the proper multiple-argument version of system:
	  e.g. system $command_line;
		   system '/bin/sh', '-c', $command_line;
	  But nobody writes the latter, unless you want things processed by a
	  different shell, like the C-shell:
	  e.g. system '/bin/csh', '-fc', $command_line;
	  The return value of the system operator is based upon the exit status of
	  the child command. In Unix, an exit value of 0 means everything is OK,
	  and a nonzero exit value usually indicates that something went wrong:
	  e.g. unless(system 'date')
	  	   {
				# Return was zero, meaning success
				print "We gave you a date, OK!\n";
		   }
B) The Environment Variables
   When you're starting another process, you may need to set up its
   environment in one way or another. You could start the process with a
   certain working directory, which it inherits from your process. Another
   common configuration detail is the environment variables, which is the %ENV
   hash.
C) The exec Function
   Everything we've just said about system syntax and semantics is also true
   about the exec function, except for one very important thing. The system
   function creates a child process, which then scuries off to perform the
   requested action while Perl naps. The exec function cause the Perl process
   itself to perform the requested action. Think of it as more like a "goto"
   than a subroutine call.
   For example, suppose you wanted to run the bedrock command in the /tmp
   directory, passing it arguments of -o args1 followed by whatever arguments
   your own program was invoked with:
   e.g. chdir '/tmp' or die "Cannot chdir /tmp: $!";
   		exec 'bedrock', '-o', 'args1', @ARGV;
   When you reach the exec operation, Perl locates bedrock and "jumps into
   it." At that point, there is no Perl process any more, just the process
   running the bedrock command. When bedrock finishes, there's no Perl to come
   back to.
   Because Perl is no longer in control once the requested command has
   started, it doesn't make any sense to have any Perl code following the
   exec, except for handling the error when the requested command cannot be
   started: 
   e.g. exec 'date';
   		die "date couldn't run: $!";
D) Using Backquotes to Capture Output
   With both system and exec, the output of the launched command ends up
   wherever Perl's standard output is going. Sometimes, it's interesting to
   capture that output as a string value to perform further processing. And
   that's done simply by creating a string using backquotes instead of single
   or double quotes:
   e.g. my $now = `date`;		#grab the output of date
   		print "The time is now $now"; #newline already present
   This is very similar to the Unix shell's meaning for backquotes. However,
   the shell also chop off the final end-of-line to make it easier to use the
   value as part of other things. Perl is honest; it gives the real output:
   e.g. chomp(my $no_newline_now = `date`);
   		print "A moment ago, it was $no_newline_now, I think.\n";
   a) Using Backquotes in a List Context
E) External Processes with IPC::System::Simple
F) Processes as Filehandles
G) Getting Down and Dirty with Fork
H) Sending and Receving Signals

Summary:
Nothing special to summary. All details are given.

Exercises:
