Book Name: Learning Perl
Author: Randal L. Schwartz, Brain D Foy, Tom Phoenix
Edition: 6th Ed
Publisher: O'Reilly
Year: 2011
ISBN: 9781449303587

Chapter 16: Process Management
A) The system Function
   The simplest way to launch a child process in Perl to run a program is the
   system command creates an identical copy of your Perl program, called the
   child process. The child process immediately changes ifself into the
   command that you want to run, such as date, inherting Perl's standard
   input, standard output, and standard error. This means that the normal
   short date-and-time string generated by date ends up wherever Perl's STDOUT
   was already going.
   e.g. see ch16eg1.pl
   a) Avoiding the Shell
   	  The system operator may also be invoked with more than one argument, in
	  which case a shell doesn't get involved, no matter how complicated the
	  text.
	  e.g. my $tarfile = 'something*wicked.tar';
	  	   my @dirs = qw(fred|flintstone <barney&rubble> betty);
		   system 'tar', 'cvf', $tarfile, @dirs;
	  The tar command will have five parameters. Compare that with this
	  security problem:
	       system "tar cvf $tarfile @dirs";
	  Here, we've now piped a bunch of stuff into a flintstone command and put
	  it into the background, and opened betty for output. That's a relatively
	  tame effect, but what if @dirs was something more interesting, such as:
	  	   my @dirs = qw(; rm -rf /);
	  It doesn't matter that @dirs is a list because Perl simply interpolates
	  it into the single string to pass to system. And that's a bit scary,
	  especially if those variables are from user input - such as from a web
	  form or something. So if you can arrange things so that you can use the
	  multiple argument version of system, you probably should use that way to
	  launch your subprocess. You'll have to give up the ability to have the
	  shell do the work for you to set up I/O redirection, background
	  processes, and the like, though.
	  Note that redundantly, a single argument invocation of system is nearly
	  equivalent to the proper multiple-argument version of system:
	  e.g. system $command_line;
		   system '/bin/sh', '-c', $command_line;
	  But nobody writes the latter, unless you want things processed by a
	  different shell, like the C-shell:
	  e.g. system '/bin/csh', '-fc', $command_line;
	  The return value of the system operator is based upon the exit status of
	  the child command. In Unix, an exit value of 0 means everything is OK,
	  and a nonzero exit value usually indicates that something went wrong:
	  e.g. unless(system 'date')
	  	   {
				# Return was zero, meaning success
				print "We gave you a date, OK!\n";
		   }
B) The Environment Variables
   When you're starting another process, you may need to set up its
   environment in one way or another. You could start the process with a
   certain working directory, which it inherits from your process. Another
   common configuration detail is the environment variables, which is the %ENV
   hash.
C) The exec Function
   Everything we've just said about system syntax and semantics is also true
   about the exec function, except for one very important thing. The system
   function creates a child process, which then scuries off to perform the
   requested action while Perl naps. The exec function cause the Perl process
   itself to perform the requested action. Think of it as more like a "goto"
   than a subroutine call.
   For example, suppose you wanted to run the bedrock command in the /tmp
   directory, passing it arguments of -o args1 followed by whatever arguments
   your own program was invoked with:
   e.g. chdir '/tmp' or die "Cannot chdir /tmp: $!";
   		exec 'bedrock', '-o', 'args1', @ARGV;
   When you reach the exec operation, Perl locates bedrock and "jumps into
   it." At that point, there is no Perl process any more, just the process
   running the bedrock command. When bedrock finishes, there's no Perl to come
   back to.
   Because Perl is no longer in control once the requested command has
   started, it doesn't make any sense to have any Perl code following the
   exec, except for handling the error when the requested command cannot be
   started: 
   e.g. exec 'date';
   		die "date couldn't run: $!";
D) Using Backquotes to Capture Output
   With both system and exec, the output of the launched command ends up
   wherever Perl's standard output is going. Sometimes, it's interesting to
   capture that output as a string value to perform further processing. And
   that's done simply by creating a string using backquotes instead of single
   or double quotes:
   e.g. my $now = `date`;		#grab the output of date
   		print "The time is now $now"; #newline already present
   This is very similar to the Unix shell's meaning for backquotes. However,
   the shell also chop off the final end-of-line to make it easier to use the
   value as part of other things. Perl is honest; it gives the real output:
   e.g. chomp(my $no_newline_now = `date`);
   		print "A moment ago, it was $no_newline_now, I think.\n";
   Instead of the backquotes, you can also use the generalized quoting
   operator, qx() that does the same thing.
   a) Using Backquotes in a List Context
   	  The scalar context use of backquotes returns the captured as a single
	  long string, even if it looks to you like there are multiple "lines"
	  because it have newlines. However, using the same backquoted string in a
	  list context yields a list containing one line of output per element.
	  e.g. see ch16eg2.pl
E) External Processes with IPC::System::Simple
   There's really not that much to say about this module because it is truly
   simple. You can use it to replace the built-in system with its own more
   robust version:
   e.g. use IPC::System::Simple qw(system);
   		my $tarfile = 'something*wicked.tar';
		my @dirs = qw(fred|flintstone <barney&rubble> betty);
		system 'tar', 'cvf', $tarfile, @dirs;
   It also provides a systemx that never use the shell:
   	    systemx 'tar', 'cvf', $tarfile, @dirs;
F) Processes as Filehandles
   Perl can also launch a child process that stays alive, communicating to
   Perl on an ongoing basis until the task is complete. The syntax for
   launching a concurrent child process is to put the command as the
   "filename" for an open call, and either precede or follow the command with
   a vertical bar, which is the "pipe" character. For that reason, this is
   often called a piped open.
   e.g. see ch16eg3.pl
G) Getting Down and Dirty with Fork
   In addition to the high-level interfaces already described, Perl provides
   nearly direct acess to the low-level process management system calls of
   Unix and some other systems.
   e.g. see ch16eg4.pl
   Here, you check the return value from fork, which is undef if it
   failed. Usually it succeeds, causing two separate processes to continue to
   the next line, but only the parent process have a nonzero value in $pid, so
   only the child process executes the exec function. The parent process skips
   over that and executes the waitpid function, waiting for that particular
   child to finish(if others finish in the meantime, they are ignored). When
   you go to this extra trouble, you also have full control over creating
   arbitary pipes, rearrangeing filehandles, and noticting your process ID and
   your parent's process ID.
H) Sending and Receving Signals
   e.g. see ch16eg5.pl

Summary:
Nothing special to summary. All details are given.

Exercises:
1) Write a program that changes to some particular(hardcored) directory, like
   the system's root directory, then executes the ls -l command to get a
   long-format directory listing in that directory.
   File Name: rootList.pl
2) Modify the previous program to send the output of the command to a file
   called ls.out in the current directory. The error output should go to a
   file called ls.err.
   File Name: rootList2.pl
3) Write a program to parse the output of the date command to determine the
   current day of the week. If the day of the week is a weekday, print get to
   work; otherwise, print go play. The output of the date command begins with
   Mon on a Monday.
   File Name: workOrPlay.pl
4) (Unix Only) Write an infinite loop program that catches signals and reports
   which signal it caught and how many times it has seen that signal
   before. Exit if you catch the INT signal. If you can use the command-line
   kill, you can send signals like so:
   		 $ kill -USR1 12345
   If you can't use the command-line kill, write another program to send
   signals to it. You might be able to get away with a Perl one-liner:
   		 $ perl -e 'kill HUP => 12345'
   File Name: signals.pl